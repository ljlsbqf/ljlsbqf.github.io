(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{519:function(e,n,t){"use strict";t.r(n);var a=t(31),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("参考：https://blog.csdn.net/weixin_42039228/article/details/123184198")]),e._v(" "),t("h3",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),t("p",[e._v("Atomic原子类：内部实现维护了一个volatile类型的value，并利用自旋和CAS来保证线程安全的")]),e._v(" "),t("p",[e._v("1、AtomicLong、AtomicInteger、AtomicBoolean：这些类实现了++，–，+delta的原子操作。\n2、AtomicReference：作用是引用类型的原子修改，保证引用的修改不会出现线程问题。\n并且通过AtomicStampedReference解决了ABA问题。")]),e._v(" "),t("p",[e._v("3、AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray：\n这个就是数组类型，和单独的对象操作基本一致，只不过在设置的时候需要填入下标罢了。")]),e._v(" "),t("p",[e._v("4、AtomicIntegerFieldUpdater、AtomicReferenceFieldUpdater、AtomicLongFieldUpdater：\nAtomicReference是修改引用，而AtomicReferenceFieldUpdater这三个类是用来修改实例对象中的属性的值的。\nAtomicIntegerFieldUpdater、AtomicLongFieldUpdater是AtomicReferenceFieldUpdater的一个特殊例子，是用来专门分别修改int和long属性的变量的。")]),e._v(" "),t("h3",{attrs:{id:"原子类和-volatile-的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原子类和-volatile-的使用场景"}},[e._v("#")]),e._v(" 原子类和 volatile 的使用场景")]),e._v(" "),t("p",[e._v("volatile 和原子类的使用场景是不一样的，如果我们有一个可见性问题，那么可以使用 volatile 关键字，但如果我们的问题是一个组合操作，需要用同步来解决原子性问题的话，那么可以使用原子变量，而不能使用 volatile 关键字。")]),e._v(" "),t("p",[e._v("通常情况下，volatile可以用来修饰boolean类型的标记位，因为对于标记位来讲，直接的赋值操作本身就是具备原子性的，再加上volatile保证了可见性，那么就是线程安全的了。")]),e._v(" "),t("p",[e._v("而对于会被多个线程同时操作的计数器Counter的场景，这种场景的一个典型特点就是，它不仅仅是一个简单的赋值操作，而是需要先读取当前的值，然后在此基础上进行一定的修改，再把它给赋值回去。这样一来，我们的volatile就不足以保证这种情况的线程安全了。我们需要使用原子类来保证线程安全。")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    private volatile int countSafe = 0;\n    private volatile int countUnSafe = 0;\n    private AtomicInteger countAutomic = new AtomicInteger(0);\n    //1、volatile 无法保证++操作的线程安全，因为一次++操作，实际是发生了一次读和一次写。并且他依赖于旧值进行更新\n    //2、如果非要如此使用，可以增加关键字synchronized。 利用volatile保证读取操作的可见性；利用synchronized保证复合操作的原子性\n    //3、建议使用原子类实现++，–，+delta等线程安全操作\n    public synchronized  void getIncrementSafe(){\n        for(int i=0;i<1000;i++){\n            countSafe++;\n        }\n    }\n    public void getIncrementUnSafe(){\n        for(int i=0;i<1000;i++){\n            countUnSafe++;\n        }\n    }\n    public void getIncrementAtomic(){\n        for(int i=0;i<1000;i++){\n            countAutomic.getAndIncrement();\n            //countAutomic.getAndAdd(1);\n        }\n    }\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br"),t("span",{staticClass:"line-number"},[e._v("18")]),t("br"),t("span",{staticClass:"line-number"},[e._v("19")]),t("br"),t("span",{staticClass:"line-number"},[e._v("20")]),t("br"),t("span",{staticClass:"line-number"},[e._v("21")]),t("br"),t("span",{staticClass:"line-number"},[e._v("22")]),t("br")])])])}),[],!1,null,null,null);n.default=i.exports}}]);