(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{534:function(t,n,a){"use strict";a.r(n);var s=a(22),e=Object(s.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-描述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-描述"}},[t._v("#")]),t._v(" 1. 描述")]),t._v(" "),a("blockquote",[a("p",[t._v("Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，子类可以使用 Object 的所有方法。日常我们创建java类，隐式继承了Object类，当然也可以显示指明")])]),t._v(" "),a("h2",{attrs:{id:"_2-方法信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-方法信息"}},[t._v("#")]),t._v(" 2. 方法信息")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("方法")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("protected Object clone()")]),t._v(" "),a("td",[t._v("创建并返回一个对象的拷贝")])]),t._v(" "),a("tr",[a("td",[t._v("boolean equals(Object obj)")]),t._v(" "),a("td",[t._v("比较")])]),t._v(" "),a("tr",[a("td",[t._v("protected void finalize()")]),t._v(" "),a("td",[t._v("当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。")])]),t._v(" "),a("tr",[a("td",[t._v("Class<?> getClass()")]),t._v(" "),a("td",[t._v("获取对象的运行时对象的类")])]),t._v(" "),a("tr",[a("td",[t._v("int hashCode()")]),t._v(" "),a("td",[t._v("获取对象的 hash 值")])]),t._v(" "),a("tr",[a("td",[t._v("String toString()")]),t._v(" "),a("td",[t._v("返回对象的字符串表示形式")])]),t._v(" "),a("tr",[a("td",[t._v("void notify()")]),t._v(" "),a("td",[t._v("唤醒在该对象上等待的某个线程")])]),t._v(" "),a("tr",[a("td",[t._v("void notifyAll()")]),t._v(" "),a("td",[t._v("唤醒在该对象上等待的所有线程")])]),t._v(" "),a("tr",[a("td",[t._v("void wait()")]),t._v(" "),a("td",[t._v("让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。")])]),t._v(" "),a("tr",[a("td",[t._v("void wait(long timeout)")]),t._v(" "),a("td",[t._v("让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过参数设置的timeout超时时间。")])]),t._v(" "),a("tr",[a("td",[t._v("void wait(long timeout, int nanos)")]),t._v(" "),a("td",[t._v("与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。")])])])]),t._v(" "),a("h3",{attrs:{id:"_3-waiting-notify-notifyall"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-waiting-notify-notifyall"}},[t._v("#")]),t._v(" 3. waiting() notify() notifyAll()")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Object wait() 方法让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。\n当前线程必须是此对象的监视器所有者，否则还是会发生 IllegalMonitorStateException 异常。\n如果当前线程在等待之前或在等待时被任何线程中断，则会抛出 InterruptedException 异常。\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Object notify() 方法用于唤醒一个在此对象监视器上等待的线程。\n如果所有的线程都在此对象上等待，那么只会选择一个线程，选择是任意性的，并在对实现做出决定时发生。\n一个线程在对象监视器上等待可以调用 wait() 方法。\nnotify() 方法只能被作为此对象监视器的所有者的线程来调用。\n一个线程要想成为对象监视器的所有者，可以使用以下 3 种方法：\n执行对象的同步实例方法\n使用 synchronized 内置锁\n对于 Class 类型的对象，执行同步静态方法\n一次只能有一个线程拥有对象的监视器。\n如果当前线程不是此对象监视器的所有者的话会抛出 IllegalMonitorStateException 异常。\n\nObject notifyAll() 方法用于唤醒在该对象上等待的所有线程。\nnotifyAll() 方法跟 notify() 方法一样，区别在于 notifyAll() 方法唤醒在此对象监视器上等待的所有线程，notify() 方法是一个线程。\n如果当前线程不是对象监视器的所有者，那么调用 notifyAll() 方法同样会发生 IllegalMonitorStateException 异常。\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br")])]),a("h3",{attrs:{id:"_4-等待-通知机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-等待-通知机制"}},[t._v("#")]),t._v(" 4.等待/通知机制")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1、一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦，体系结构上具备了良好的伸缩性.\n\n2、简单的方式是使用while(flag)不停判断，但是这样子增加了cpu使用，如果增加线程休眠时间又导致通知的时效性\n\n3、通过内置的等待/通知机制能够很好地解决这个矛盾并实现。使用object对象的wait()和notify()方法可以很好实现。\n4、等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);