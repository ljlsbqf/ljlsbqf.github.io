(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{526:function(t,n,r){"use strict";r.r(n);var a=r(30),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,r=t._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("参考：https://www.jb51.net/article/226912.htm\nhttps://zhuanlan.zhihu.com/p/462991317")]),t._v(" "),r("h3",{attrs:{id:"说明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[t._v("#")]),t._v(" 说明：")]),t._v(" "),r("p",[t._v("synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：")]),t._v(" "),r("p",[t._v("1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；")]),t._v(" "),r("p",[t._v("2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；")]),t._v(" "),r("p",[t._v("3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；")]),t._v(" "),r("p",[t._v("4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。")]),t._v(" "),r("h3",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理：")]),t._v(" "),r("p",[t._v("Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，")]),t._v(" "),r("h3",{attrs:{id:"总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结：")]),t._v(" "),r("p",[t._v("1、 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。")]),t._v(" "),r("p",[t._v("2、每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。")]),t._v(" "),r("p",[t._v("3、实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制")])])}),[],!1,null,null,null);n.default=e.exports}}]);