(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{524:function(a,t,n){"use strict";n.r(t);var r=n(30),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"java锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java锁"}},[a._v("#")]),a._v(" java锁")]),a._v(" "),n("p",[a._v("参考：https://www.cnblogs.com/linghu-java/p/8944784.html")]),a._v(" "),n("p",[a._v("https://baijiahao.baidu.com/s?id=1724437003950645037&wfr=spider&for=pc")]),a._v(" "),n("p",[a._v("从宏观角度，锁分为乐观锁和悲观锁。")]),a._v(" "),n("p",[a._v("乐观锁：认为数据读多写少，并发修改的概率低。java中基本使用使用CAS算法实现\n悲观锁：认为数据写多，遇到并发修改概率大，通过加锁实现数据安全，比如使用关键字Synchronized、ReentrantLock等")]),a._v(" "),n("p",[a._v("Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在\nJava SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状\n态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏\n向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高\n获得锁和释放锁的效率，")]),a._v(" "),n("p",[a._v("偏向锁：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下MarkWord中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程")])])}),[],!1,null,null,null);t.default=e.exports}}]);