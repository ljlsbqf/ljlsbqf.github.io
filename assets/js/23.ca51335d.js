(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{535:function(t,v,a){"use strict";a.r(v);var l=a(22),e=Object(l.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("参考 https://blog.csdn.net/csdn2497242041/article/details/120183612")]),t._v(" "),a("p",[t._v("https://www.zybuluo.com/kiraSally/note/850631#5-synchronized-vs-volatile")]),t._v(" "),a("h3",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),a("p",[t._v("Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。")]),t._v(" "),a("p",[t._v("一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：")]),t._v(" "),a("p",[t._v("1）变量可见性：保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。")]),t._v(" "),a("p",[t._v("2）禁止重排序：volatile禁止了指令重排。比sychronized更轻量级的同步锁。在访问volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。volatile适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。")]),t._v(" "),a("h3",{attrs:{id:"适用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适用场景"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),a("p",[t._v("对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。在某些场景下可以代替Synchronized。但是，volatile的不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。")]),t._v(" "),a("p",[t._v("总体来说，需要必须同时满足下面两个条件时才能保证并发环境的线程安全：")]),t._v(" "),a("p",[t._v("1： 写入变量时并不依赖变量的当前值；或者能够确保只有单一线程能够修改变量的值")]),t._v(" "),a("p",[t._v("2： 变量不需要与其他的状态变量共同参与不变约束")]),t._v(" "),a("p",[t._v("3： 变量访问不需要额外加锁")]),t._v(" "),a("p",[t._v("通俗点： 当一个变量依赖其他变量或变量的新值依赖旧值时，不能用volatile")]),t._v(" "),a("p",[t._v("适用场合：多个线程读，一个线程写的场合")]),t._v(" "),a("p",[t._v("使用场景：通常被作为标识完成、中断、状态的标记，值变化应具有原子性(比如作为任务执行的开关)")]),t._v(" "),a("p",[t._v("充分利用其可见性：即volatile能够保证在读取的那个时刻读到的肯定是最新值")]),t._v(" "),a("h3",{attrs:{id:"为什么volatile不能保证原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么volatile不能保证原子性"}},[t._v("#")]),t._v(" 为什么volatile不能保证原子性")]),t._v(" "),a("p",[t._v("https://blog.csdn.net/qq_46190347/article/details/109908724")]),t._v(" "),a("p",[t._v("volatile只有写操作是原子性的，也就是数据操作完成后会立刻刷新到主内存中。但是被volatile修饰的变量在读的时候可能会被多个线程读。也就是说int i = 1;i++；\nA线程读 i = 1同时B线程也读了i = 1，然后自增完成刷新入主内存。i的值是2。")]),t._v(" "),a("p",[t._v("所以如果该变量是volatile修饰的，那可以完全保证此时取到的是最新信息。但在入栈和自增计算执行过程中，该变量有可能正在被其他线程修改，最后计算出来的结果照样存在问题，因此volatile并不能保证非原子操作的原子性，仅在单次读或者单次写这样的原子操作中，volatile能够实现线程安全")]),t._v(" "),a("h3",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),a("p",[t._v("为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。同时内存屏障还能保证内存的可见性。内存屏障是一组处理器指令，它的作用是禁止指令重排序和解决内存可见性的问题。")])])}),[],!1,null,null,null);v.default=e.exports}}]);